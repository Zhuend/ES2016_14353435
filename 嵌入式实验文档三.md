# 嵌入式实验文档三

## 实验过程

首先我们需要将相应的classA，classB以及我们实现的class Deadlock写入一个java文件中。同时为了提高死锁发生的概率，我们需要对原来的count变量进行一些调节。在本次实验中，我取的count值为180000。完成后的代码如下图：

![fig-1](http://yotuku.cn/link?url=V1LgGupef&tk_plan=free&tk_storage=tietuku&tk_vuid=185a405a-dc73-4b02-856e-eef98f9ad6a3&tk_time=2016111022)

然后我们对java文件使用javac指令进行编译，得到我们需要的class文件。之后，需要写一个批处理文件来重复执行Deadlock.class文件，以观察死锁的发生。这里需要注意的是，由于我本次实验是运行在linux环境下的，所以linux环境下的批处理文件并不是.bat文件，而是.sh文件。所以我们编写好的shell批处理文件如下：

![fig-2](http://yotuku.cn/link?url=VJEzM_aeM&tk_plan=free&tk_storage=tietuku&tk_vuid=185a405a-dc73-4b02-856e-eef98f9ad6a3&tk_time=2016111022)

需要注意的是在linux下运行批处理文件时，需要先关闭dash模式，具体语句如下：

![fig-4](http://yotuku.cn/link?url=N1P3XO6xG&tk_plan=free&tk_storage=tietuku&tk_vuid=185a405a-dc73-4b02-856e-eef98f9ad6a3&tk_time=2016111022)

这里我们为了能够更好地观察到死锁发生，我把执行次数调整为了10000次，这样就有更大地可能捕捉到死锁的发生。执行sh批处理文件后，我们可以看到死锁发生如下图：

![fig-3](http://yotuku.cn/link?url=V197M_TeM&tk_plan=free&tk_storage=tietuku&tk_vuid=185a405a-dc73-4b02-856e-eef98f9ad6a3&tk_time=2016111022)

可以看出，死锁发生在第483次运行时。

## 死锁发生条件

### 互斥条件

互斥条件说的是，对于一个资源而言，它一次只可以被一个进程所占用，而不存在两个进程同时占有一个资源的情况。互斥条件保证了一个资源只可能一次被一个进程占用。

### 请求与保持条件

请求与保持条件说的是当一个线程获得资源时，它在运行完成前不会释放资源；而之后申请该资源的进程则会被阻塞，陷入等待状态。

### 不剥夺条件

不剥夺条件是说，当一个占有资源并执行的过程中，是不可以被其他资源剥夺资源的。这也就是说，该过程是非抢占的。

### 循环等待条件

循环等待条件是说，有一系列进程相继申请资源，并分别被阻塞而陷入等待状态。并且着一系列进程的等待状态是首尾相连，最后形成了一个环路，造成谁也无法跳出阻塞状态的局面。这也就直接导致了死锁的出现。

## 实验分析

本次实验中我们用来研究思索地例子是一个较为简单的例子，我们有两个对象A和B，并且实现对应的成员函数，在A对象内调用B对象，而在B对象内调用A对象。然后我们在主线程内又创建了一个子线程，并在主线程内做一个延迟后运行A对象的成员函数用于调用B对象，然后在子线程内运行B对象的成员函数用于调用A对象。注意的是A，B均是对象，一次只可以在一个线程中运行，而线程的运行调度是由操作系统划分时间片来实现的。假如主线程内未在规定的时间片内运行完，而子线程中又调用了A对象，则会发生死锁现象。